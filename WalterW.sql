-- ==========================================================
-- 2. CREACIÓN DE TABLAS
-- ==========================================================

-- 2.1. Usuarios (Tabla Padre)
CREATE TABLE Usuarios (
    dni               VARCHAR2(15) NOT NULL,
    nombre            VARCHAR2(100) NOT NULL,
    apellido_paterno  VARCHAR2(100) NOT NULL,
    apellido_materno  VARCHAR2(100),
    CONSTRAINT pk_usuarios PRIMARY KEY (dni)
);

-- 2.2. Clientes y Empleados (Herencia)
CREATE TABLE Clientes (
    dni VARCHAR2(15) NOT NULL,
    CONSTRAINT pk_clientes PRIMARY KEY (dni),
    CONSTRAINT fk_clientes_usuarios FOREIGN KEY (dni) REFERENCES Usuarios(dni) ON DELETE CASCADE
);

CREATE TABLE Empleados (
    dni               VARCHAR2(15) NOT NULL,
    puesto            VARCHAR2(50) NOT NULL,
    fecha_contratacion DATE DEFAULT SYSDATE,
    usuario_sistema   VARCHAR2(50) UNIQUE NOT NULL,
    CONSTRAINT pk_empleados PRIMARY KEY (dni),
    CONSTRAINT fk_empleados_usuarios FOREIGN KEY (dni) REFERENCES Usuarios(dni) ON DELETE CASCADE
);

-- 2.3. Inventario
CREATE TABLE Proveedores (
    id_proveedor      NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    nombre            VARCHAR2(100) NOT NULL,
    contacto_telefono VARCHAR2(15),
    email             VARCHAR2(100),
    direccion         VARCHAR2(255),
    estado            VARCHAR2(10) DEFAULT 'Activo' NOT NULL,
    CONSTRAINT pk_proveedores PRIMARY KEY (id_proveedor)
);

CREATE TABLE Categorias (
    id_categoria      NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    nombre            VARCHAR2(100) NOT NULL,
    descripcion       VARCHAR2(255),
    CONSTRAINT pk_categorias PRIMARY KEY (id_categoria)
);

CREATE TABLE Medicamentos (
    id_medicamento    NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    nombre            VARCHAR2(100) NOT NULL,
    id_categoria      NUMBER(10) NOT NULL,
    id_proveedor      NUMBER(10),
    stock             NUMBER(6) DEFAULT 0 NOT NULL,
    precio_compra     NUMBER(10, 2) NOT NULL,
    precio_venta      NUMBER(10, 2) NOT NULL,
    fecha_vencimiento DATE NOT NULL,
    lote              VARCHAR2(50) NOT NULL,
    ubicacion         VARCHAR2(50), -- Es opcional (NULL permitido)
    descripcion       VARCHAR2(500), -- Es opcional (NULL permitido)
    estado            VARCHAR2(10) DEFAULT 'Activo' NOT NULL,
    CONSTRAINT pk_medicamentos PRIMARY KEY (id_medicamento),
    CONSTRAINT fk_medicamentos_cat FOREIGN KEY (id_categoria) REFERENCES Categorias(id_categoria),
    CONSTRAINT fk_medicamentos_prov FOREIGN KEY (id_proveedor) REFERENCES Proveedores(id_proveedor),
    CONSTRAINT chk_medicamentos_stock CHECK (stock >= 0)
);

-- 2.4. Ventas y Auditoría
CREATE TABLE Ventas (
    id_venta          NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    dni_cliente       VARCHAR2(15) NOT NULL,
    dni_empleado      VARCHAR2(15) NOT NULL,
    fecha_venta       TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
    total_venta       NUMBER(10, 2) DEFAULT 0,
    CONSTRAINT pk_ventas PRIMARY KEY (id_venta),
    CONSTRAINT fk_ventas_cli FOREIGN KEY (dni_cliente) REFERENCES Clientes(dni),
    CONSTRAINT fk_ventas_emp FOREIGN KEY (dni_empleado) REFERENCES Empleados(dni)
);

CREATE TABLE Venta_Detalle (
    id_detalle        NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    id_venta          NUMBER(10) NOT NULL,
    id_medicamento    NUMBER(10) NOT NULL,
    cantidad          NUMBER(4) NOT NULL,
    precio_unitario_venta NUMBER(10, 2) NOT NULL,
    subtotal AS (cantidad * precio_unitario_venta),
    CONSTRAINT pk_venta_detalle PRIMARY KEY (id_detalle),
    CONSTRAINT fk_detalle_vta FOREIGN KEY (id_venta) REFERENCES Ventas(id_venta) ON DELETE CASCADE,
    CONSTRAINT fk_detalle_med FOREIGN KEY (id_medicamento) REFERENCES Medicamentos(id_medicamento)
);

CREATE TABLE Auditoria_Medicamentos (
    id_auditoria      NUMBER(10) GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    id_medicamento_afectado NUMBER(10),
    nombre_medicamento  VARCHAR2(100),
    accion_realizada    VARCHAR2(2000),
    usuario_db          VARCHAR2(50),
    fecha_accion        TIMESTAMP DEFAULT SYSTIMESTAMP,
    CONSTRAINT pk_auditoria PRIMARY KEY (id_auditoria)
);

-- ==========================================================
-- 3. TRIGGERS
-- ==========================================================

-- 3.1.

CREATE OR REPLACE TRIGGER trg_control_stock_inteligente
AFTER INSERT ON Venta_Detalle FOR EACH ROW
DECLARE
    v_stock_actual NUMBER;
    v_nombre_med VARCHAR2(100);
    v_precio_compra NUMBER(10,2);
    v_precio_venta NUMBER(10,2);
    v_ganancia NUMBER(10,2);
    v_margen_porcentaje NUMBER(5,2);
BEGIN
    -- Obtener información del medicamento
    SELECT stock, nombre, precio_compra, precio_venta
    INTO v_stock_actual, v_nombre_med, v_precio_compra, v_precio_venta
    FROM Medicamentos
    WHERE id_medicamento = :NEW.id_medicamento;
    
    -- Validar stock suficiente
    IF v_stock_actual < :NEW.cantidad THEN
        RAISE_APPLICATION_ERROR(-20003, 
            'Stock insuficiente para ' || v_nombre_med || 
            '. Disponible: ' || v_stock_actual || ', Solicitado: ' || :NEW.cantidad);
    END IF;
    
    -- Calcular métricas de rentabilidad y auditar si es necesario
    v_margen_porcentaje := ROUND(((v_precio_venta - v_precio_compra) / v_precio_venta) * 100, 2);
    IF v_margen_porcentaje < 20 THEN
        INSERT INTO Auditoria_Medicamentos (
            id_medicamento_afectado, nombre_medicamento, accion_realizada, usuario_db, fecha_accion
        ) VALUES (
            :NEW.id_medicamento, v_nombre_med, 'VENTA_MARGEN_BAJO: ' || v_margen_porcentaje || '% | Cant: ' || :NEW.cantidad, USER, SYSTIMESTAMP
        );
    END IF;
    
    -- Reducir stock. El estado ('Agotado' o 'Activo') será actualizado por el trigger trg_validar_medicamento_completo
    UPDATE Medicamentos
    SET stock = stock - :NEW.cantidad
    WHERE id_medicamento = :NEW.id_medicamento;
    
    -- Si el stock resultante es crítico (<=5), registrar alerta de auditoría
    IF (v_stock_actual - :NEW.cantidad) <= 5 AND (v_stock_actual - :NEW.cantidad) > 0 THEN
        INSERT INTO Auditoria_Medicamentos (
            id_medicamento_afectado, nombre_medicamento, accion_realizada, usuario_db, fecha_accion
        ) VALUES (
            :NEW.id_medicamento, v_nombre_med, 'ALERTA_STOCK_CRITICO: Quedan ' || (v_stock_actual - :NEW.cantidad) || ' unidades', USER, SYSTIMESTAMP
        );
    END IF;
    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        RAISE_APPLICATION_ERROR(-20002, 'Medicamento no encontrado ID: ' || :NEW.id_medicamento);
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20099, 'Error en control de stock: ' || SQLERRM);
END;
/

-- 3.2.

CREATE OR REPLACE TRIGGER trg_validar_medicamento_completo
BEFORE INSERT OR UPDATE ON Medicamentos FOR EACH ROW
DECLARE
    v_dias_para_vencer NUMBER;
    v_count_lote NUMBER;
BEGIN
    -- No permitir cambios a registros lógicamente eliminados, a menos que se esté reactivando
    IF :OLD.estado = 'Inactivo' AND :NEW.estado = 'Inactivo' THEN
        RAISE_APPLICATION_ERROR(-20010, 'No se pueden modificar medicamentos marcados como Inactivos.');
    END IF;
    
    -- 1. Validar fecha de vencimiento (no puede ser pasada)
    IF :NEW.fecha_vencimiento < TRUNC(SYSDATE) THEN
        RAISE_APPLICATION_ERROR(-20001, 
            'No se puede registrar medicamento vencido. Fecha: ' || 
            TO_CHAR(:NEW.fecha_vencimiento, 'DD/MM/YYYY'));
    END IF;
    
    -- 2. Validar si está próximo a vencer (menos de 60 días)
    v_dias_para_vencer := :NEW.fecha_vencimiento - TRUNC(SYSDATE);
    IF v_dias_para_vencer <= 60 AND v_dias_para_vencer > 0 THEN
        DBMS_OUTPUT.PUT_LINE('⚠️  ADVERTENCIA: ' || :NEW.nombre || 
                            ' vence en ' || v_dias_para_vencer || ' días');
    END IF;
    
    -- 3. Validar precios lógicos
    IF :NEW.precio_venta <= :NEW.precio_compra THEN
        RAISE_APPLICATION_ERROR(-20004, 
            'Precio de venta debe ser mayor al precio de compra. ' ||
            'Compra: S/.' || :NEW.precio_compra || ', Venta: S/.' || :NEW.precio_venta);
    END IF;
    
    -- 4. Validar margen mínimo del 10%
    IF ((:NEW.precio_venta - :NEW.precio_compra) / :NEW.precio_venta) < 0.10 THEN
        RAISE_APPLICATION_ERROR(-20005, 
            'Margen de ganancia muy bajo (menor al 10%). Ajuste los precios.');
    END IF;
    
    -- 5. Validar duplicado de lote
    IF INSERTING THEN
        SELECT COUNT(*) INTO v_count_lote
        FROM Medicamentos
        WHERE lote = :NEW.lote 
          AND nombre = :NEW.nombre
          AND id_medicamento != NVL(:NEW.id_medicamento, -1);
        
        IF v_count_lote > 0 THEN
            RAISE_APPLICATION_ERROR(-20006, 
                'Ya existe un medicamento con el lote ' || :NEW.lote || 
                '. Use un lote diferente o verifique si es reposición.');
        END IF;
    END IF;
    
    -- 6. GESTIÓN DE ESTADO CENTRALIZADA
    -- Solo se gestiona el estado si no está siendo marcado como 'Inactivo' manualmente.
    -- El estado 'Inactivo' tiene prioridad para borrados lógicos.
    IF :NEW.estado != 'Inactivo' THEN
        IF :NEW.stock <= 0 THEN
            :NEW.estado := 'Agotado';
        ELSE
            -- Si el stock es positivo, siempre debe estar 'Activo'.
            -- Esto también resuelve el caso de reponer stock a un producto 'Agotado'.
            :NEW.estado := 'Activo';
        END IF;
    END IF;
    
END;
/

-- 3.3. 

CREATE OR REPLACE TRIGGER trg_auditoria_avanzada_medicamentos
AFTER INSERT OR UPDATE OR DELETE ON Medicamentos FOR EACH ROW
DECLARE
    v_accion VARCHAR2(500);
    v_detalles VARCHAR2(2000) := ''; -- Aumentado para más detalles
BEGIN
    IF INSERTING THEN
        v_accion := 'REGISTRO_NUEVO';
        v_detalles := 'Stock inicial: ' || :NEW.stock || 
                     ' | Precio Venta: S/.' || :NEW.precio_venta ||
                     ' | Vence: ' || TO_CHAR(:NEW.fecha_vencimiento, 'DD/MM/YYYY') ||
                     ' | Lote: ' || :NEW.lote;
        
    ELSIF DELETING THEN
        v_accion := 'ELIMINACION_FISICA';
        v_detalles := 'Se eliminó permanentemente el registro. ' ||
                     'Último stock: ' || :OLD.stock ||
                     ' | Último estado: ' || :OLD.estado ||
                     ' | Lote: ' || :OLD.lote ||
                     ' | Valor inventario perdido: S/.' || ROUND(:OLD.stock * :OLD.precio_compra, 2);

    ELSIF UPDATING THEN
        v_accion := 'ACTUALIZACION';
        
        -- Construir una cadena con todos los cambios detectados
        IF :OLD.nombre != :NEW.nombre THEN
            v_detalles := v_detalles || 'Nombre: "' || :OLD.nombre || '" -> "' || :NEW.nombre || '". ';
        END IF;
        IF :OLD.stock != :NEW.stock THEN
            v_detalles := v_detalles || 'Stock: ' || :OLD.stock || ' -> ' || :NEW.stock || '. ';
        END IF;
        IF :OLD.precio_compra != :NEW.precio_compra THEN
            v_detalles := v_detalles || 'P. Compra: ' || :OLD.precio_compra || ' -> ' || :NEW.precio_compra || '. ';
        END IF;
        IF :OLD.precio_venta != :NEW.precio_venta THEN
            v_detalles := v_detalles || 'P. Venta: ' || :OLD.precio_venta || ' -> ' || :NEW.precio_venta || '. ';
        END IF;
        IF :OLD.estado != :NEW.estado THEN
            v_detalles := v_detalles || 'Estado: "' || :OLD.estado || '" -> "' || :NEW.estado || '". ';
        END IF;
        IF :OLD.lote != :NEW.lote THEN
            v_detalles := v_detalles || 'Lote: "' || :OLD.lote || '" -> "' || :NEW.lote || '". ';
        END IF;
        
        -- Si no se detectó ningún cambio auditable, no se inserta nada
        IF LENGTH(v_detalles) = 0 THEN
            RETURN; -- Salir del trigger si no hay cambios relevantes
        END IF;
        
        -- Si el único cambio es para marcar como inactivo, usar un mensaje más específico
        IF :OLD.estado != 'Inactivo' AND :NEW.estado = 'Inactivo' AND v_detalles = 'Estado: "' || :OLD.estado || '" -> "' || :NEW.estado || '". ' THEN
            v_accion := 'ELIMINACION_LOGICA';
        END IF;
        
    END IF;

    -- Insertar el registro de auditoría
    INSERT INTO Auditoria_Medicamentos (
        id_medicamento_afectado,
        nombre_medicamento,
        accion_realizada,
        usuario_db,
        fecha_accion
    ) VALUES (
        NVL(:NEW.id_medicamento, :OLD.id_medicamento), -- Usar NEW para INSERT/UPDATE, OLD para DELETE
        NVL(:NEW.nombre, :OLD.nombre),
        v_accion || ' - ' || v_detalles,
        USER,
        SYSTIMESTAMP
    );
    
EXCEPTION
    WHEN OTHERS THEN
        -- No interfiere con la operación principal si la auditoría falla
        DBMS_OUTPUT.PUT_LINE('Error en auditoría (no crítico): ' || SQLERRM);
END;
/

-- ==========================================================
-- 5. PAQUETE DE GESTIÓN
-- ==========================================================
CREATE OR REPLACE PACKAGE pkg_gestion_farmacia AS
    PROCEDURE p_registrar_medicamento (
        p_nombre IN VARCHAR2, p_id_categoria IN NUMBER, p_id_proveedor IN NUMBER,
        p_stock IN NUMBER, p_precio_compra IN NUMBER, p_precio_venta IN NUMBER,
        p_fecha_vencimiento IN VARCHAR2, p_lote IN VARCHAR2,
        p_ubicacion IN VARCHAR2 DEFAULT NULL, p_descripcion IN VARCHAR2 DEFAULT NULL
    );

    PROCEDURE p_editar_medicamento_completo (
        p_id_medicamento IN NUMBER, p_nombre IN VARCHAR2, p_id_categoria IN NUMBER, p_id_proveedor IN NUMBER,
        p_stock IN NUMBER, p_precio_compra IN NUMBER, p_precio_venta IN NUMBER,
        p_fecha_vencimiento IN VARCHAR2, p_lote IN VARCHAR2, p_ubicacion IN VARCHAR2 DEFAULT NULL, p_descripcion IN VARCHAR2 DEFAULT NULL
    );

    PROCEDURE p_editar_precio (p_id_medicamento IN NUMBER, p_nuevo_precio_compra IN NUMBER, p_nuevo_precio_venta IN NUMBER);
    PROCEDURE p_actualizar_stock (p_id_medicamento IN NUMBER, p_cantidad_agregada IN NUMBER);
    
    PROCEDURE p_eliminar_medicamento (p_id_medicamento IN NUMBER);
    PROCEDURE p_cambiar_estado_medicamento (p_id_medicamento IN NUMBER, p_nuevo_estado IN VARCHAR2);

    PROCEDURE p_registrar_venta_con_cliente (
        p_dni_cliente IN VARCHAR2, p_nombre_cli IN VARCHAR2, p_ape_pat_cli IN VARCHAR2, p_ape_mat_cli IN VARCHAR2,
        p_dni_empleado IN VARCHAR2, p_total_venta IN NUMBER, p_id_venta_generada OUT NUMBER
    );
END pkg_gestion_farmacia;
/

CREATE OR REPLACE PACKAGE BODY pkg_gestion_farmacia AS
    PROCEDURE p_registrar_medicamento (
        p_nombre IN VARCHAR2, p_id_categoria IN NUMBER, p_id_proveedor IN NUMBER,
        p_stock IN NUMBER, p_precio_compra IN NUMBER, p_precio_venta IN NUMBER,
        p_fecha_vencimiento IN VARCHAR2, p_lote IN VARCHAR2, p_ubicacion IN VARCHAR2, p_descripcion IN VARCHAR2
    ) AS BEGIN
        INSERT INTO Medicamentos (nombre, id_categoria, id_proveedor, stock, precio_compra, precio_venta, fecha_vencimiento, lote, ubicacion, descripcion)
        VALUES (p_nombre, p_id_categoria, p_id_proveedor, p_stock, p_precio_compra, p_precio_venta, TO_DATE(p_fecha_vencimiento,'YYYY-MM-DD'), p_lote, p_ubicacion, p_descripcion);
        COMMIT;
    END;

    PROCEDURE p_editar_medicamento_completo (
        p_id_medicamento IN NUMBER, p_nombre IN VARCHAR2, p_id_categoria IN NUMBER, p_id_proveedor IN NUMBER,
        p_stock IN NUMBER, p_precio_compra IN NUMBER, p_precio_venta IN NUMBER,
        p_fecha_vencimiento IN VARCHAR2, p_lote IN VARCHAR2, p_ubicacion IN VARCHAR2, p_descripcion IN VARCHAR2
    ) AS BEGIN
        UPDATE Medicamentos SET nombre = p_nombre, id_categoria = p_id_categoria, id_proveedor = p_id_proveedor,
            stock = p_stock, precio_compra = p_precio_compra, precio_venta = p_precio_venta,
            fecha_vencimiento = TO_DATE(p_fecha_vencimiento, 'YYYY-MM-DD'), lote = p_lote, ubicacion = p_ubicacion, descripcion = p_descripcion
        WHERE id_medicamento = p_id_medicamento;
        COMMIT;
    END;

    PROCEDURE p_editar_precio (p_id_medicamento IN NUMBER, p_nuevo_precio_compra IN NUMBER, p_nuevo_precio_venta IN NUMBER) AS BEGIN
        UPDATE Medicamentos SET precio_compra = p_nuevo_precio_compra, precio_venta = p_nuevo_precio_venta WHERE id_medicamento = p_id_medicamento;
        COMMIT;
    END;

    PROCEDURE p_actualizar_stock (p_id_medicamento IN NUMBER, p_cantidad_agregada IN NUMBER) AS BEGIN
        UPDATE Medicamentos SET stock = stock + p_cantidad_agregada, estado = CASE WHEN estado='Agotado' THEN 'Activo' ELSE estado END WHERE id_medicamento = p_id_medicamento;
        COMMIT;
    END;

    PROCEDURE p_eliminar_medicamento (p_id_medicamento IN NUMBER) AS BEGIN
        UPDATE Medicamentos SET estado = 'Inactivo' WHERE id_medicamento = p_id_medicamento;
        COMMIT;
    END;

    PROCEDURE p_cambiar_estado_medicamento (p_id_medicamento IN NUMBER, p_nuevo_estado IN VARCHAR2) AS 
        v_stock NUMBER;
    BEGIN
        -- Si se quiere reactivar, verificamos el stock para saber si queda en Activo o Agotado
        IF p_nuevo_estado = 'Activo' THEN
            SELECT stock INTO v_stock FROM Medicamentos WHERE id_medicamento = p_id_medicamento;
            IF v_stock <= 0 THEN
                UPDATE Medicamentos SET estado = 'Agotado' WHERE id_medicamento = p_id_medicamento;
            ELSE
                UPDATE Medicamentos SET estado = 'Activo' WHERE id_medicamento = p_id_medicamento;
            END IF;
        ELSE
            -- Si es Inactivo u otro, se aplica directo
            UPDATE Medicamentos SET estado = p_nuevo_estado WHERE id_medicamento = p_id_medicamento;
        END IF;
        COMMIT;
    END;

    PROCEDURE p_registrar_venta_con_cliente (
        p_dni_cliente IN VARCHAR2, p_nombre_cli IN VARCHAR2, p_ape_pat_cli IN VARCHAR2, p_ape_mat_cli IN VARCHAR2,
        p_dni_empleado IN VARCHAR2, p_total_venta IN NUMBER, p_id_venta_generada OUT NUMBER
    ) AS BEGIN
        MERGE INTO Usuarios u USING (SELECT p_dni_cliente AS dni FROM dual) s ON (u.dni = s.dni)
        WHEN MATCHED THEN UPDATE SET nombre = p_nombre_cli, apellido_paterno = p_ape_pat_cli, apellido_materno = p_ape_mat_cli
        WHEN NOT MATCHED THEN INSERT (dni, nombre, apellido_paterno, apellido_materno) VALUES (p_dni_cliente, p_nombre_cli, p_ape_pat_cli, p_ape_mat_cli);

        INSERT INTO Clientes (dni) SELECT p_dni_cliente FROM DUAL WHERE NOT EXISTS (SELECT 1 FROM Clientes WHERE dni = p_dni_cliente);
        INSERT INTO Ventas (dni_cliente, dni_empleado, total_venta) VALUES (p_dni_cliente, p_dni_empleado, p_total_venta) RETURNING id_venta INTO p_id_venta_generada;
    END;
END pkg_gestion_farmacia;
/

-- ==========================================================
-- 6. PAQUETE REPORTES
-- ==========================================================
CREATE OR REPLACE PACKAGE pkg_reportes_farmacia AS
    TYPE T_CURSOR IS REF CURSOR;

    -- 1. Inventario General
    PROCEDURE p_reporte_medicamentos_por_categoria (p_cursor OUT T_CURSOR);
    
    -- 2. Rentabilidad
    PROCEDURE p_reporte_rentabilidad_productos (p_cursor OUT T_CURSOR);
    
    -- 3. Bajo Stock
    PROCEDURE p_reporte_medicamentos_bajo_stock_detalle (p_cursor OUT T_CURSOR);
    
    -- 4. Inactivos
    PROCEDURE p_reporte_medicamentos_inactivos (p_cursor OUT T_CURSOR);
    
    -- 5. Vencimientos
    PROCEDURE p_reporte_medicamentos_proximos_vencer (p_dias IN NUMBER, p_cursor OUT T_CURSOR);
    
    -- 6. Stock Crítico
    PROCEDURE p_reporte_medicamentos_sin_stock (p_cursor OUT T_CURSOR);
    
    -- 7. Ventas por Empleado
    PROCEDURE p_reporte_ventas_por_empleado (p_cursor OUT T_CURSOR);
    
    -- 8. Ventas por Cliente
    PROCEDURE p_reporte_ventas_por_cliente (p_cursor OUT T_CURSOR);
    
    -- 9. Top Vendidos
    PROCEDURE p_reporte_top_5_vendidos (p_cursor OUT T_CURSOR);
    
    -- 10. Ingresos Mensuales
    PROCEDURE p_reporte_ingresos_por_mes (p_cursor OUT T_CURSOR);

END pkg_reportes_farmacia;
/

CREATE OR REPLACE PACKAGE BODY pkg_reportes_farmacia AS

    -- 1. INVENTARIO GENERAL
    PROCEDURE p_reporte_medicamentos_por_categoria (p_cursor OUT T_CURSOR) AS BEGIN
        OPEN p_cursor FOR 
            SELECT c.nombre as categoria, m.nombre as medicamento, p.nombre as proveedor, m.stock, m.precio_venta 
            FROM Medicamentos m 
            JOIN Categorias c ON m.id_categoria = c.id_categoria 
            LEFT JOIN Proveedores p ON m.id_proveedor = p.id_proveedor
            WHERE m.estado = 'Activo' ORDER BY c.nombre, m.nombre;
    END;

    -- 2. RENTABILIDAD (NUEVO) - ENHANCED
    PROCEDURE p_reporte_rentabilidad_productos (p_cursor OUT T_CURSOR) AS BEGIN
        OPEN p_cursor FOR 
            SELECT m.nombre, c.nombre as categoria, p.nombre as proveedor, m.stock, m.precio_compra, m.precio_venta, 
                   (m.precio_venta - m.precio_compra) AS ganancia_unitaria,
                   ROUND(((m.precio_venta - m.precio_compra) / NULLIF(m.precio_venta,0)) * 100, 1) AS margen_porcentaje
            FROM Medicamentos m
            JOIN Categorias c ON m.id_categoria = c.id_categoria
            LEFT JOIN Proveedores p ON m.id_proveedor = p.id_proveedor
            WHERE m.estado = 'Activo' ORDER BY ganancia_unitaria DESC;
    END;

    -- 3. BAJO STOCK DETALLADO (REEMPLAZA AUDITORÍA) - ENHANCED
    PROCEDURE p_reporte_medicamentos_bajo_stock_detalle (p_cursor OUT T_CURSOR) AS BEGIN
        OPEN p_cursor FOR 
            SELECT m.nombre, c.nombre as categoria, p.nombre as proveedor, m.stock, m.precio_compra, m.precio_venta, m.ubicacion, m.lote, m.fecha_vencimiento
            FROM Medicamentos m
            JOIN Categorias c ON m.id_categoria = c.id_categoria
            LEFT JOIN Proveedores p ON m.id_proveedor = p.id_proveedor
            WHERE m.stock <= 10 AND m.estado = 'Activo'
            ORDER BY m.stock ASC;
    END;

    -- 4. INACTIVOS (NUEVO) - ENHANCED
    PROCEDURE p_reporte_medicamentos_inactivos (p_cursor OUT T_CURSOR) AS BEGIN
        OPEN p_cursor FOR 
            SELECT m.nombre, c.nombre as categoria, p.nombre as proveedor, m.lote, m.ubicacion, m.stock, m.precio_compra, m.fecha_vencimiento
            FROM Medicamentos m
            JOIN Categorias c ON m.id_categoria = c.id_categoria
            LEFT JOIN Proveedores p ON m.id_proveedor = p.id_proveedor
            WHERE m.estado = 'Inactivo' ORDER BY m.nombre;
    END;

    -- 5. VENCIMIENTOS (Próximos días)
    PROCEDURE p_reporte_medicamentos_proximos_vencer (p_dias IN NUMBER, p_cursor OUT T_CURSOR) AS BEGIN 
        OPEN p_cursor FOR 
            SELECT nombre, lote, fecha_vencimiento, (fecha_vencimiento - TRUNC(SYSDATE)) as dias_restantes
            FROM Medicamentos 
            WHERE fecha_vencimiento BETWEEN TRUNC(SYSDATE) AND (TRUNC(SYSDATE) + p_dias) AND estado = 'Activo'
            ORDER BY fecha_vencimiento ASC; 
    END;

    -- 6. SIN STOCK
    PROCEDURE p_reporte_medicamentos_sin_stock (p_cursor OUT T_CURSOR) AS BEGIN 
        OPEN p_cursor FOR 
            SELECT nombre, lote, estado, id_proveedor
            FROM Medicamentos WHERE stock <= 0 OR estado = 'Agotado'; 
    END;

    -- 7. VENTAS POR EMPLEADO
    PROCEDURE p_reporte_ventas_por_empleado (p_cursor OUT T_CURSOR) AS BEGIN
        OPEN p_cursor FOR 
            SELECT u.nombre || ' ' || u.apellido_paterno as empleado, COUNT(v.id_venta) as total_ventas, SUM(v.total_venta) as total_dinero
            FROM Ventas v JOIN Empleados e ON v.dni_empleado = e.dni JOIN Usuarios u ON e.dni = u.dni 
            GROUP BY u.nombre, u.apellido_paterno ORDER BY total_dinero DESC;
    END;

    -- 8. VENTAS POR CLIENTE
    PROCEDURE p_reporte_ventas_por_cliente (p_cursor OUT T_CURSOR) AS BEGIN
        OPEN p_cursor FOR 
            SELECT u.nombre || ' ' || u.apellido_paterno as cliente, COUNT(v.id_venta) as compras, SUM(v.total_venta) as gastado
            FROM Ventas v JOIN Clientes c ON v.dni_cliente = c.dni JOIN Usuarios u ON c.dni = u.dni 
            GROUP BY u.nombre, u.apellido_paterno ORDER BY gastado DESC;
    END;

    -- 9. TOP 5 VENDIDOS
    PROCEDURE p_reporte_top_5_vendidos (p_cursor OUT T_CURSOR) AS BEGIN 
        OPEN p_cursor FOR 
            SELECT m.nombre, c.nombre as categoria, SUM(d.cantidad) as total_unidades
            FROM Venta_Detalle d 
            JOIN Medicamentos m ON d.id_medicamento = m.id_medicamento 
            JOIN Categorias c ON m.id_categoria = c.id_categoria
            GROUP BY m.nombre, c.nombre ORDER BY total_unidades DESC FETCH FIRST 5 ROWS ONLY; 
    END;

    -- 10. INGRESOS MENSUALES
    PROCEDURE p_reporte_ingresos_por_mes (p_cursor OUT T_CURSOR) AS BEGIN 
        OPEN p_cursor FOR 
            SELECT TO_CHAR(fecha_venta, 'YYYY-MM') as mes, COUNT(id_venta) as num_ventas, SUM(total_venta) as total_ingresos
            FROM Ventas GROUP BY TO_CHAR(fecha_venta, 'YYYY-MM') ORDER BY mes DESC; 
    END;

END pkg_reportes_farmacia;
/
